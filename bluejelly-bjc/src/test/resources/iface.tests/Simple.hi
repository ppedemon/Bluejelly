module Simple(Simple.f,Simple.Either(Simple.Left,Simple.Right)) where

import Helper

infixl 5 ++,$$,**
infixr 6 &&&,^^^

f,g :: (Prelude.Eq a, Prelude.Ord a) => 
  (a -> b -> bluejelly.Int.Int) -> 
  ([bluejelly.String.String],bluejelly.Char.Char) -> 
  (bluejelly.Int.Int, bluejelly.Int.Int)

data Simple.Eq a => Either a b = Left a | Right b

data Person = Manager {
    name   :: bluejelly.String.String, 
    org    :: bluejelly.String.String, 
    people :: [Simple.Person]
  } 
  | Employee {
    name    :: !bluejelly.String.String, 
    manager :: Simple.Person
  }

-- Wtf?
data Simple.Monad m => M m = M { x :: m a -> a }

class Functor m where
  map :: (a -> b) -> m a -> m b

class Simple.Functor m => Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b

class Eq a where
  (==),(/=) :: a -> a -> bluejelly.Base.Bool
  x /= y = not (x == y)

type Set a = [a]
type Point = (bluejelly.Int.Int,bluejelly.Int.Int)

instance Simple.Eq bluejelly.Int.Int where 
  x == y = bluejelly.Int.eq x y

instance (Simple.Eq a, Simple.Eq b) => Simple.Eq (a,b) where 
  (u,v) == (x,y) = u == x && v == y

instance Simple.Eq a => Simple.Eq [a] where
  [] == [] = True
  (x:xs) == (y:ys) = x == y && xs == ys
  _ == _ = False

instance (Simple.Eq a, Simple.Eq b) => Simple.Eq (a->b) where
  f == g = True

data X a = X [a]

class Arrow a where
  op :: a b c -> a b c -> a b c
