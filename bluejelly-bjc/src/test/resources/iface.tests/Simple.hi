module Simple(Simple.f,Simple.Either(Simple.Left,Simple.Right)) where

import bluejelly.Prelude
import bluejelly.Types
import bluejelly.List
import bluejelly.Int

infixl 5 ++,$$,**
infixr 6 &&&,^^^

f,g :: (Eq a, Ord a) => (a -> b -> Int) -> ([String],Char) -> (Int,Int)

data Eq a => Either a b = Left a | Right b

data Person = Manager {name::String, org::String, people::[Person]} 
            | Employee {name:: !String, manager::Person}

-- Wtf?
data Monad m => M m = M { x :: m a -> a }

class Functor m where
  map :: (a -> b) -> m a -> m b

class Functor m => Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b

class Eq a where
  (==),(/=) :: a -> a -> Bool
  x /= y = not (x == y)

type Set a = [a]
type Point = (Int,Int)
 
instance Eq Int where 
  x == y = bluejelly.Int.eq x y

instance (Eq a,Eq b) => Eq (a,b) where 
  (u,v) == (x,y) = u == x && v == y

instance Eq a => Eq [a] where
  [] == [] = True
  (x:xs) == (y:ys) = x == y && xs == ys
  _ == _ = False

instance (Eq a,Eq b) => Eq (a->b) where
  f == g = True

data X a = X [a]
