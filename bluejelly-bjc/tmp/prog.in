module bluejelly.X(module custom.B,module S) where

import A
import B()
import B hiding()

import qualified custom.B(a,b,c,Eq((==),(/=)))
import qualified container.Set as S hiding(a,C(a,(+)),Z(..),)
x::Int
y::[Char]
a,(+),(-):: forall a b . Prelude.Eq a => a -> a
map :: forall a b . (a -> b) -> A (A x) ([[[a]]],[b])
(>>=) :: forall a b . Monad m => (m (((a)))) -> (a -> b) -> m b
empty :: () => a -> b

polyRank :: (forall a . a -> a) -> 
            (forall a b . (a -> b) -> M a -> b) -> 
            b
            
f :: (C [a] b,D _ _, M [] (->)) => [a] -> [b] -> c
map :: forall a b . (->) a b -> [] a -> [] b
tuple :: (,) Int ((,) a b) -> (Int,(a,b))
g :: (a -> b) -> (c -> d)

type Stack a = [a]

data Eq a => List a = Nil 
                    | forall a . Ord a => Cons a (List a)
                    | Record {a,b,c :: !Int, stack :: forall a. Stack a}
                    | StrictCons !a !(List a)
                    | Existencial (forall a . a -> a) (x.M.T a) (a -> (a->b) -> b) 
newtype T a = T a
data () => Abstract a
data Num a => Complex a = !a :+ !a
data Num a => Cmplx a = (:+) (forall a . a) !a

x
C 1 2
v@(C _ x)
1
1.2
'\\'
'"'
'\''
"a\
\\"\''a\u4f60"
x :+ y
[]
x:xs
w:x:y:z:xs
x:(y:zs)
(,) 1 2 :+ -(C (-x) ~(Z x y))
(1 :+ 2) :+ b
[x,1,z@(1 :+ i)]
a `x.M.X` ((b `Z` c) :: a -> a -> Z a)
Point {x,y,z=Point 0 0 0}
(:+) 3 4


